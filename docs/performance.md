# Звіт з профілювання продуктивності Telegram-бота

## 1. Використані інструменти профілювання

- `cProfile` — для CPU-профілювання Python-коду
- `pstats` — для аналізу результатів профілювання
- `asyncio` + `AsyncMock` — для імітації роботи асинхронного Telegram-бота

## 2. Методологія

1. Створено тестовий сценарій, який викликає основні функції обробки команд `/start` та `/help`.
2. Використано `unittest.mock.AsyncMock` для симуляції `update.message.reply_text()`.
3. Профілювання запускалося за допомогою `asyncio.run()`.

## 3. Метрики продуктивності

```
27097 function calls (25974 primitive calls) in 0.011 seconds
```

### Топ-10 функцій за сукупним часом:

| # | Функція / Файл | Кількість викликів | Сукупний час (`cumtime`) |
|--|------------------|---------------------|----------------------------|
| 1 | `asyncio.runners:run` | 1 | **0.011 с** |
| 2 | `asyncio.base_events:run_until_complete` | 3 | 0.010 с |
| 3 | `asyncio.windows_events:run_forever` | 3 | 0.010 с |
| 4 | `asyncio.base_events:run_forever` | 3 | 0.010 с |
| 5 | `base_events:_run_once` | 6 | 0.010 с |
| 6 | `events:_run` | 11 | 0.010 с |
| 7 | `{method 'run' of '_contextvars.Context'}` | 11 | 0.010 с |
| 8 | `profile_bot.py:test_scenario` | 1 | 0.010 с |
| 9 | `unittest.mock:__init__` | 15 | 0.007 с |
|10 | `unittest.mock:_mock_add_spec` | 15 | 0.007 с |

## 4. Виявлені гарячі точки

1. Запуск `asyncio.run()` і цикл подій — очікувано займає найбільше часу.
2. Ініціалізація `MagicMock` / `AsyncMock` — значні накладні витрати.
3. Основна логіка сконцентрована в одному `test_scenario` — є потенціал для оптимізації.

## 5. Пропозиції щодо покращення

- Перенести окремі функції в менші підмодулі для кращого контролю часу виконання.
- Уникати зайвих `mock`-об'єктів у продакшн-коді.
- Додатково перевірити продуктивність у реальному середовищі Telegram API.